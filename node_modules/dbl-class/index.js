/*globals define:true, window:true, module:true*/
(function () {

  // for extend callParent  
  Function.prototype.defineMethod = function (methodName, methodBody) {
    this.prototype[methodName] = methodBody;
    // if ((typeof methodBody) == 'function')
    if (methodBody) {
      methodBody.$name = methodName;
      methodBody.$owner = this;
    }
  };
  // Namespace object
  var my = {};
  // Return as AMD module or attach to head object
  if (typeof define !== 'undefined')
    define([], function () {
      return my;
    });
  else if (typeof window !== 'undefined')
    window.my = my;
  else
    module.exports = my;




  var Events = require('dbl-events');


  var Module = {
    __bindEvents__ : function(events) {
      var eventName, key, match, method, selector, _results,
        _this = this;
      _results = [];
      for (key in events) {
        method = events[key];
        if (typeof method !== 'function') {
          method = (function(method) {
            return function() {
              _this[method].apply(_this, arguments);
              return true;
            };
          })(method);
        }
        match = key.match(eventSplitter);
        eventName = match[1];
        selector = match[2];
        if (selector === '') {
          _results.push(this.el.bind(eventName, method));
        } else {
          _results.push(this.el.delegate(selector, eventName, method));
        }
      }
      return _results;
    },
    __unbindEvents__ : function(events) {
      var eventName, key, match, method, selector, _results,
        _this = this;
      _results = [];
      for (key in events) {
        match = key.match(eventSplitter);
        eventName = match[1];
        selector = match[2];
        if (selector === '') {
          _results.push(this.el.unbind(eventName, method));
        } else {
          _results.push(this.el.undelegate(selector, eventName));
        }
      }
      return _results;
    },
    proxy:function(func){
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    },
    callParent: function() {
      var method = arguments.callee.caller;
      return method.$owner.$baseType.prototype[method.$name].apply(this, arguments);
    }
  };

  //============================================================================
  // @method my.Class
  // @params body:Object
  // @params SuperClass:function, ImplementClasses:function..., body:Object
  // @description:
  // @return function
  my.createClass = function () {

    var len = arguments.length;
    var body = arguments[len - 1];
    var SuperClass = len > 1 ? arguments[0] : null;
    var hasImplementClasses = len > 2;
    var Class, SuperClassEmpty;

    if (body.constructor === Object) {
      Class = function() {};
    } else {
      Class = body.constructor;
      delete body.constructor;
    }

    if (SuperClass) {
      SuperClassEmpty = function() {};
      SuperClassEmpty.prototype = SuperClass.prototype;
      Class.prototype = new SuperClassEmpty();
      // Class.prototype.constructor = Class;
      Class.defineMethod('constructor', Class);
      Class.Super = SuperClass;
      extend(Class, SuperClass, false);
      Class.$baseType = SuperClass;
      // Class.super = function () {
      //   return SuperClass.prototype;
      // };

    }
    var fn = Class.prototype;


    if (hasImplementClasses)
      for (var i = 1; i < len - 1; i++)
        extend(fn, arguments[i].prototype, false);    

    extendClass(Class, body);

    //追加事件代理
    extend(fn,Events);

    extend(fn,Module);


    return Class;

  };

  //============================================================================
  // @method my.extendClass
  // @params Class:function, extension:Object, ?override:boolean=true
  var extendClass = my.extendClass = function (Class, extension, override) {
    if (extension.STATIC) {
      extend(Class, extension.STATIC, override);
      delete extension.STATIC;
    }
    // extend(Class.prototype, extension, override);
    var prop;
    if (override === false) {
      for (prop in extension)
        if (!(prop in Class.prototype))
          Class.defineMethod(prop, extension[prop]);
    } else {
      for (prop in extension)
        Class.defineMethod(prop, extension[prop]);
      if (extension.toString !== Object.prototype.toString)
        Class.defineMethod('toString', extension.toString);
    }
  };

  //============================================================================
  var extend = my.extend = function (obj, extension, override) {
    var prop;
    if (override === false) {
      for (prop in extension)
        if (!(prop in obj))
          obj[prop] = extension[prop];
    } else {
      for (prop in extension)
        obj[prop] = extension[prop];
      if (extension.toString !== Object.prototype.toString)
        obj.toString = extension.toString;
    }
  };




})();